{{- $vendorsPath := "_vendors" -}}
{{- $vendors := slice -}}

{{- range $path := (readDir $vendorsPath) -}}
  {{- if not $path.IsDir -}}
    {{- $filePath := printf "%s/%s" $vendorsPath $path.Name -}}
    {{- $content := readFile $filePath -}}
    {{- $data := $content | transform.Unmarshal -}}
    {{- $vendors = $vendors | append $data -}}
  {{- end -}}
{{- end -}}

<style>
  .sortable-table {
    border-collapse: collapse;
    width: 100%;
  }
  .sortable-table th {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 25px;
    padding-top: 12px;
    padding-bottom: 12px;
  }
  .sortable-table th:hover {
    background-color: #808689;
  }
  .sortable-table th::after {
    content: '↕';
    position: absolute;
    right: 8px;
    opacity: 0.3;
    font-size: 0.9em;
  }
  .sortable-table th.sort-asc::after {
    content: '↑';
    opacity: 1;
  }
  .sortable-table th.sort-desc::after {
    content: '↓';
    opacity: 1;
  }
  .sortable-table th:last-child {
    cursor: default;
  }
  .sortable-table th:last-child::after {
    content: '';
  }
  .percent-cell[data-notes]:not([data-notes=""]) {
    position: relative;
    cursor: help;
  }
  .percent-cell[data-notes]:not([data-notes=""])::after {
    content: ' *';
    color: #83A4A2;
  }
  .percent-cell[data-notes]:not([data-notes=""]):hover::after {
    content: attr(data-notes);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 12px;
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    white-space: nowrap;
    font-size: 0.9em;
    z-index: 1000;
    margin-bottom: 5px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  }
  .percent-cell[data-notes]:not([data-notes=""]):hover::before {
    content: '';
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: #333;
    margin-bottom: -5px;
  }
  @media (prefers-color-scheme: dark) {
    .percent-cell[data-notes]:not([data-notes=""]):hover::after {
      background-color: #ecebf3;
      color: #0c120c;
    }
    .percent-cell[data-notes]:not([data-notes=""]):hover::before {
      border-top-color: #ecebf3;
    }
  }
</style>

<table class="sortable-table" id="vendor-table">
  <thead>
    <tr>
      <th data-sort="string">Vendor</th>
      <th data-sort="price">Base Pricing</th>
      <th data-sort="price">RBAC Pricing</th>
      <th data-sort="percent">% Increase</th>
      <th data-sort="date">Updated</th>
      <th>Links</th>
    </tr>
  </thead>
  <tbody>
    {{- range $vendors -}}
    <tr>
      <td>
        {{- if .vendor_url -}}
          <a href="{{ .vendor_url }}" target="_blank">{{ .name }}</a>
        {{- else -}}
          {{ .name }}
        {{- end -}}
      </td>
      <td data-value="{{ .base_pricing }}">{{ .base_pricing }}</td>
      <td data-value="{{ .rbac_pricing }}">{{ .rbac_pricing }}</td>
      <td class="percent-cell" data-value="{{ .percent_increase }}" data-notes="{{ .notes }}">{{ .percent_increase }}</td>
      <td data-value="{{ .updated_at }}">{{ .updated_at }}</td>
      <td>
        {{- if .pricing_source -}}
          <a href="{{ .pricing_source }}" target="_blank">Pricing</a>
        {{- end -}}
      </td>
    </tr>
    {{- end -}}
  </tbody>
</table>

<script>
(function() {
  const table = document.getElementById('vendor-table');
  const headers = table.querySelectorAll('th[data-sort]');

  // Parse different data types
  function parseValue(value, type) {
    if (!value) return '';

    switch(type) {
      case 'price':
        // Remove currency symbols and extract number
        return parseFloat(value.replace(/[^0-9.]/g, '')) || 0;
      case 'percent':
        // Remove % sign and extract number
        return parseFloat(value.replace(/[^0-9.-]/g, '')) || 0;
      case 'date':
        // Parse date string
        return new Date(value).getTime() || 0;
      case 'string':
      default:
        return value.toLowerCase();
    }
  }

  // Sort table by column
  function sortTable(columnIndex, sortType, ascending) {
    const tbody = table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));

    rows.sort((a, b) => {
      const aCell = a.cells[columnIndex];
      const bCell = b.cells[columnIndex];

      const aValue = parseValue(aCell.dataset.value || aCell.textContent, sortType);
      const bValue = parseValue(bCell.dataset.value || bCell.textContent, sortType);

      if (aValue < bValue) return ascending ? -1 : 1;
      if (aValue > bValue) return ascending ? 1 : -1;
      return 0;
    });

    // Re-append rows in sorted order
    rows.forEach(row => tbody.appendChild(row));
  }

  // Add click handlers to headers
  headers.forEach((header, index) => {
    let ascending = true;

    header.addEventListener('click', function() {
      // Remove sort classes from all headers
      headers.forEach(h => {
        h.classList.remove('sort-asc', 'sort-desc');
      });

      // Add appropriate class to clicked header
      if (ascending) {
        header.classList.add('sort-asc');
      } else {
        header.classList.add('sort-desc');
      }

      // Sort the table
      const sortType = header.dataset.sort;
      sortTable(index, sortType, ascending);

      // Toggle sort direction for next click
      ascending = !ascending;
    });
  });
})();
</script>
